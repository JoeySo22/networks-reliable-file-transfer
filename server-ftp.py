from genericpath import exists
from multiprocessing import connection
import os
from socket import AF_INET, SOCK_STREAM, socket
from threading import Thread
import re

port_regex_pattern = re.compile('^([1-9][0-9]{0,3}|[1-5][0-9]{4}|6[0-4]' +
    '[0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])$')

class FTPSession(Thread):

    def __init__(self, connection, address):
        Thread.__init__(self)
        self.socket = connection
        self.addr = address
        print('Connection accepted from ' + self.addr[0])

    def run(self):
        print(str(self) + 'running...')
        while True:
            message: list[str] = self.socket.recv(1000).decode().split(' ')
            if message[0] == 'RETR':
                file_path = './server_repo/' + message[1]
                self.file_name = message[1]
                if exists(file_path):
                    '''I need to create an application header for my ftp 
                    application. 
                    
                    We use a 64 bit architecture (not that it matters too 
                    much in this context) so we have 8 bytes we can use. Some
                    important information is the length of the file and 
                    the filename. So we must have routine to add the header to
                    the data. Data is obviously the file data. 
                    '''
                    self.generate_header(file_path)
                    # Send the file
                    self.send_file(file_path)
                else:
                    self.socket.sendall('NO')
            elif message[0] == 'CLOSE':
                print('Connection closed, See you later!')
                self.socket.close()
                return

    def generate_header(self, file_path: str) -> None:
        '''The size of the file is generated by getting the size then encoding
        it into bytes and storing it. The size of the header of size is 10 bytes
        '''
        size_of_file = str(os.path.getsize(file_path)).encode()
        self.header = (b'0' * (10 - len(size_of_file))) + size_of_file
        ''' TOTAL SIZE OF HEADER: 10 bytes'''

    def send_file(self, file_path):
        self.socket.send(b'OK')
        self.socket.sendall(self.header)
        with open(file_path, 'rb') as _file:
            # To send only 1000 bytes at a time
            data = _file.read(1000)
            while data:
                # Send truncated header and data together
                self.socket.sendall(data)
                data = _file.read(1000)
            print('Transfer Complete!')


def process_port() -> int:
    valid_input = False
    while not valid_input:
        user_input = input('Listen at port# ')
        valid_input = validate_port(user_input)
        if valid_input:
            return int(user_input)

def validate_port(input):
    return re.fullmatch(port_regex_pattern, input)    


if __name__ == '__main__':
    connections = []
    listening_socket = socket(AF_INET, SOCK_STREAM)
    listening_socket.bind(('10.0.0.20', process_port()))
    print('Listening...', end='')
    listening_socket.listen(5)
    while True:
        connection, address = listening_socket.accept()
        session = FTPSession(connection, address)
        session.start()
        connections.append(session)

